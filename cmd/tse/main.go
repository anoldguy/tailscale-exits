package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/anoldguy/tse/cmd/tse/ui"
	"github.com/anoldguy/tse/shared/regions"
	"github.com/anoldguy/tse/shared/types"
)

const Version = "1.0.0"

const Usage = `Tailscale Ephemeral Exit Node Service CLI

Usage:
  tse version                   - Show version information
  tse setup [flags]             - Configure Tailscale for exit nodes (one-time)
  tse deploy                    - Deploy AWS infrastructure (Lambda, IAM, etc.)
  tse status                    - Show AWS infrastructure deployment status
  tse teardown                  - Delete all TSE infrastructure (requires confirmation)
  tse health                    - Check Lambda health
  tse shutdown                  - Stop exit nodes in ALL regions
  tse <region> instances        - List instances in region
  tse <region> start            - Start exit node in region
  tse <region> stop             - Stop exit nodes in region
  tse <region> cleanup          - Clean up orphaned TSE resources in region

Available regions: %s

Environment Variables:
  TAILSCALE_AUTH_KEY    - Tailscale auth key (required for setup and deploy)
  TSE_AUTH_TOKEN        - Auth token for Lambda API (generated by deploy)
  TSE_LAMBDA_URL        - Lambda Function URL (required for exit node operations)

Examples:
  tse setup                      # Configure Tailscale (first time)
  tse deploy                     # Deploy AWS infrastructure
  tse status                     # Check infrastructure deployment
  tse teardown                   # Delete all infrastructure
  tse health
  tse shutdown                   # Stop exit nodes everywhere
  tse ohio instances
  tse ohio start
  tse ohio stop
`

func main() {
	if len(os.Args) < 2 {
		showUsage()
		os.Exit(1)
	}

	command := os.Args[1]

	// Handle version command
	if command == "version" || command == "--version" || command == "-v" {
		fmt.Printf("tse version %s\n", Version)
		return
	}

	// Handle setup command (doesn't require TSE_LAMBDA_URL)
	if command == "setup" {
		err := runSetup(os.Args[2:])
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
		return
	}

	// Handle status command (doesn't require TSE_LAMBDA_URL)
	if command == "status" {
		if len(os.Args) != 2 {
			showUsage()
			os.Exit(1)
		}
		err := runStatus(os.Args[2:])
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
		return
	}

	// Handle deploy command (doesn't require TSE_LAMBDA_URL)
	if command == "deploy" {
		if len(os.Args) != 2 {
			showUsage()
			os.Exit(1)
		}
		err := runDeploy(os.Args[2:])
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
		return
	}

	// Handle teardown command (doesn't require TSE_LAMBDA_URL)
	if command == "teardown" {
		if len(os.Args) != 2 {
			showUsage()
			os.Exit(1)
		}
		err := runTeardown(os.Args[2:])
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
		return
	}

	// All other commands require TSE_LAMBDA_URL
	lambdaURL := os.Getenv("TSE_LAMBDA_URL")
	if lambdaURL == "" {
		fmt.Fprintf(os.Stderr, "%s TSE_LAMBDA_URL environment variable not set\n", ui.Error("Error:"))
		fmt.Fprintf(os.Stderr, "\n%s First run 'tse setup' to configure Tailscale, then deploy the Lambda.\n", ui.Info("Hint:"))
		os.Exit(1)
	}

	// Remove trailing slash if present
	lambdaURL = strings.TrimSuffix(lambdaURL, "/")

	// Handle health check (special case)
	if command == "health" {
		if len(os.Args) != 2 {
			showUsage()
			os.Exit(1)
		}
		err := handleHealth(lambdaURL)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
		return
	}

	// Handle shutdown (stop all regions)
	if command == "shutdown" {
		if len(os.Args) != 2 {
			showUsage()
			os.Exit(1)
		}
		err := handleShutdown(lambdaURL)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
		return
	}

	// All other commands require region + action
	if len(os.Args) != 3 {
		showUsage()
		os.Exit(1)
	}

	region := command
	action := os.Args[2]

	// Validate region
	if !regions.IsValidFriendlyName(region) {
		fmt.Fprintf(os.Stderr, "%s Invalid region %s\n", ui.Error("Error:"), ui.Highlight(region))
		fmt.Fprintf(os.Stderr, "Available regions: %s\n", regions.GetAvailableRegions())
		os.Exit(1)
	}

	// Handle actions
	switch action {
	case "instances":
		err := handleInstances(lambdaURL, region)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
	case "start":
		err := handleStart(lambdaURL, region)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
	case "stop":
		err := handleStop(lambdaURL, region)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
	case "cleanup":
		err := handleCleanup(lambdaURL, region)
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s %v\n", ui.Error("Error:"), err)
			os.Exit(1)
		}
	default:
		fmt.Fprintf(os.Stderr, "%s Invalid action %s\n", ui.Error("Error:"), ui.Highlight(action))
		fmt.Fprintf(os.Stderr, "Valid actions: instances, start, stop, cleanup\n")
		os.Exit(1)
	}
}

func showUsage() {
	fmt.Printf(Usage, regions.GetAvailableRegions())
}

func getAuthToken() string {
	return os.Getenv("TSE_AUTH_TOKEN")
}

func makeAuthenticatedRequest(method, url string, body io.Reader) (*http.Response, error) {
	req, err := http.NewRequest(method, url, body)
	if err != nil {
		return nil, err
	}

	// Add Authorization header if token is set
	if token := getAuthToken(); token != "" {
		req.Header.Set("Authorization", "Bearer "+token)
	}

	client := &http.Client{
		Timeout: 30 * time.Second,
	}
	resp, err := client.Do(req)

	// Add helpful context to network errors
	if err != nil {
		return nil, enhanceHTTPError(err, url)
	}

	return resp, nil
}

// enhanceHTTPError adds helpful troubleshooting context to HTTP errors
func enhanceHTTPError(err error, url string) error {
	if strings.Contains(err.Error(), "timeout") {
		return fmt.Errorf("request timed out after 30s\n\nTroubleshooting:\n  - Check your internet connection\n  - Verify TSE_LAMBDA_URL is correct: %s\n  - Lambda might be cold-starting (rare, try again)\n\nOriginal error: %w", url, err)
	}

	if strings.Contains(err.Error(), "no such host") || strings.Contains(err.Error(), "connection refused") {
		return fmt.Errorf("cannot reach Lambda endpoint\n\nTroubleshooting:\n  - Is TSE_LAMBDA_URL set correctly? %s\n  - Did you run 'tse deploy' first?\n  - Check 'tse status' to verify infrastructure exists\n\nOriginal error: %w", url, err)
	}

	return fmt.Errorf("network error: %w\n\nCheck your internet connection and verify TSE_LAMBDA_URL: %s", err, url)
}

// enhanceHTTPStatusError adds context based on HTTP status codes
func enhanceHTTPStatusError(statusCode int, body, operation string) error {
	switch statusCode {
	case 401:
		return fmt.Errorf("%s failed (HTTP 401 Unauthorized)\n\nTroubleshooting:\n  - Check TSE_AUTH_TOKEN is set correctly\n  - Token might have expired or been rotated\n  - Run 'tse deploy' to regenerate token\n\nResponse: %s", operation, body)
	case 403:
		return fmt.Errorf("%s failed (HTTP 403 Forbidden)\n\nTroubleshooting:\n  - Lambda might not have IAM permissions\n  - Check CloudWatch logs for Lambda errors\n  - Run 'tse status' to verify deployment\n\nResponse: %s", operation, body)
	case 404:
		return fmt.Errorf("%s failed (HTTP 404 Not Found)\n\nTroubleshooting:\n  - Check TSE_LAMBDA_URL is correct\n  - Endpoint might not exist (check Lambda handler)\n  - Verify region name is valid\n\nResponse: %s", operation, body)
	case 500, 502, 503:
		return fmt.Errorf("%s failed (HTTP %d Server Error)\n\nTroubleshooting:\n  - Lambda encountered an internal error\n  - Check CloudWatch logs: /aws/lambda/tailscale-exits\n  - Common causes: AWS quota limits, IAM permissions, Tailscale auth key issues\n\nResponse: %s", operation, statusCode, body)
	default:
		return fmt.Errorf("%s failed (HTTP %d)\n\nResponse: %s", operation, statusCode, body)
	}
}

func handleHealth(lambdaURL string) error {
	resp, err := makeAuthenticatedRequest("GET", lambdaURL, nil)
	if err != nil {
		return err // Already enhanced with context
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return enhanceHTTPStatusError(resp.StatusCode, string(body), "health check")
	}

	var health types.HealthResponse
	if err := json.Unmarshal(body, &health); err != nil {
		return fmt.Errorf("failed to parse health response: %w", err)
	}

	fmt.Printf("%s %s\n", ui.Label("Status:"), ui.Success(health.Status))
	fmt.Printf("%s %s\n", ui.Label("Version:"), health.Version)
	fmt.Printf("%s %s\n", ui.Label("Timestamp:"), ui.Subtle(health.Timestamp))

	return nil
}

func handleInstances(lambdaURL, region string) error {
	url := fmt.Sprintf("%s/%s/instances", lambdaURL, region)
	resp, err := makeAuthenticatedRequest("GET", url, nil)
	if err != nil {
		return err // Already enhanced with context
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return enhanceHTTPStatusError(resp.StatusCode, string(body), fmt.Sprintf("list instances in %s", region))
	}

	var instancesResp types.InstancesResponse
	if err := json.Unmarshal(body, &instancesResp); err != nil {
		return fmt.Errorf("failed to parse response: %w", err)
	}

	fmt.Printf("Instances in %s region: %s\n", ui.Highlight(region), ui.Bold(fmt.Sprintf("%d", instancesResp.Count)))
	if instancesResp.Count == 0 {
		fmt.Println(ui.Subtle("No instances found."))
		return nil
	}

	fmt.Println()
	for _, instance := range instancesResp.Instances {
		fmt.Printf("%s %s\n", ui.Label("Instance ID:"), ui.Highlight(instance.InstanceID))
		fmt.Printf("  %s %s\n", ui.Label("State:"), ui.Success(instance.State))
		fmt.Printf("  %s %s\n", ui.Label("Type:"), instance.InstanceType)
		fmt.Printf("  %s %s\n", ui.Label("Launch Time:"), ui.Subtle(instance.LaunchTime.Format(time.RFC3339)))
		if instance.PublicIP != "" {
			fmt.Printf("  %s %s\n", ui.Label("Public IP:"), ui.Highlight(instance.PublicIP))
		}
		if instance.TailscaleHostname != "" {
			fmt.Printf("  %s %s\n", ui.Label("Tailscale Hostname:"), ui.Highlight(instance.TailscaleHostname))
		}
		fmt.Println()
	}

	return nil
}

func handleStart(lambdaURL, region string) error {
	url := fmt.Sprintf("%s/%s/start", lambdaURL, region)
	resp, err := makeAuthenticatedRequest("POST", url, nil)
	if err != nil {
		return err // Already enhanced with context
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}

	// Handle 409 Conflict gracefully (instance already running)
	if resp.StatusCode == http.StatusConflict {
		var errorResp types.ErrorResponse
		if json.Unmarshal(body, &errorResp) == nil {
			fmt.Printf("%s %s\n", ui.Info("Info:"), errorResp.Error)
			return nil
		}
	}

	if resp.StatusCode != http.StatusCreated {
		return enhanceHTTPStatusError(resp.StatusCode, string(body), fmt.Sprintf("start exit node in %s", region))
	}

	var startResp types.StartResponse
	if err := json.Unmarshal(body, &startResp); err != nil {
		return fmt.Errorf("failed to parse response: %w", err)
	}

	fmt.Printf("%s %s\n", ui.Checkmark(), startResp.Message)
	if startResp.Instance != nil {
		fmt.Printf("%s %s\n", ui.Label("Instance ID:"), ui.Highlight(startResp.Instance.InstanceID))
		fmt.Printf("%s %s\n", ui.Label("Instance Type:"), startResp.Instance.InstanceType)
		fmt.Printf("%s %s\n", ui.Label("Tailscale Hostname:"), ui.Highlight(startResp.Instance.TailscaleHostname))
		fmt.Printf("%s %s\n", ui.Label("State:"), ui.Success(startResp.Instance.State))
		fmt.Printf("\n%s It may take 1-2 minutes for the exit node to become available in Tailscale.\n", ui.Subtle("Note:"))
	}

	return nil
}

func handleStop(lambdaURL, region string) error {
	url := fmt.Sprintf("%s/%s/stop", lambdaURL, region)
	resp, err := makeAuthenticatedRequest("POST", url, bytes.NewReader([]byte("{}")))
	if err != nil {
		return err // Already enhanced with context
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return enhanceHTTPStatusError(resp.StatusCode, string(body), fmt.Sprintf("stop exit node in %s", region))
	}

	var stopResp types.StopResponse
	if err := json.Unmarshal(body, &stopResp); err != nil {
		return fmt.Errorf("failed to parse response: %w", err)
	}

	fmt.Printf("%s %s\n", ui.Checkmark(), stopResp.Message)
	if stopResp.TerminatedCount > 0 {
		fmt.Printf("%s %v\n", ui.Label("Terminated instances:"), stopResp.TerminatedIDs)
	}

	return nil
}

func handleCleanup(lambdaURL, region string) error {
	url := fmt.Sprintf("%s/%s/cleanup", lambdaURL, region)
	resp, err := makeAuthenticatedRequest("POST", url, bytes.NewReader([]byte("{}")))
	if err != nil {
		return err // Already enhanced with context
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return enhanceHTTPStatusError(resp.StatusCode, string(body), fmt.Sprintf("cleanup resources in %s", region))
	}

	var cleanupResp types.StopResponse // Reuse stop response structure
	if err := json.Unmarshal(body, &cleanupResp); err != nil {
		return fmt.Errorf("failed to parse response: %w", err)
	}

	fmt.Printf("%s %s\n", ui.Checkmark(), cleanupResp.Message)
	if cleanupResp.TerminatedCount > 0 {
		fmt.Printf("%s %v\n", ui.Label("Cleaned up resources:"), cleanupResp.TerminatedIDs)
	} else {
		fmt.Println(ui.Subtle("No orphaned TSE resources found."))
	}

	return nil
}

func handleShutdown(lambdaURL string) error {
	fmt.Println(ui.Title("Stopping exit nodes in all regions..."))
	fmt.Println()

	allRegions := regions.GetAllFriendlyNames()
	totalTerminated := 0
	regionsWithInstances := []string{}

	for _, region := range allRegions {
		url := fmt.Sprintf("%s/%s/stop", lambdaURL, region)
		resp, err := makeAuthenticatedRequest("POST", url, bytes.NewReader([]byte("{}")))
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s failed to contact Lambda for %s: %v\n", ui.Warning("Warning:"), region, err)
			continue
		}

		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			fmt.Fprintf(os.Stderr, "%s failed to read response for %s: %v\n", ui.Warning("Warning:"), region, err)
			continue
		}

		if resp.StatusCode != http.StatusOK {
			// Check if it's a 404 (no instances found) vs actual error
			if resp.StatusCode == http.StatusNotFound {
				// No instances in this region, which is expected - continue silently
				continue
			}
			// Actual error - warn the user
			fmt.Fprintf(os.Stderr, "%s stop failed for %s (HTTP %d): %s\n", ui.Warning("Warning:"), region, resp.StatusCode, string(body))
			continue
		}

		var stopResp types.StopResponse
		if err := json.Unmarshal(body, &stopResp); err != nil {
			fmt.Fprintf(os.Stderr, "%s failed to parse response for %s: %v\n", ui.Warning("Warning:"), region, err)
			continue
		}

		if stopResp.TerminatedCount > 0 {
			fmt.Printf("%s %s: terminated %s instance(s)\n",
				ui.Checkmark(),
				ui.Highlight(region),
				ui.Bold(fmt.Sprintf("%d", stopResp.TerminatedCount)))
			totalTerminated += stopResp.TerminatedCount
			regionsWithInstances = append(regionsWithInstances, region)
		}
	}

	fmt.Println()
	if totalTerminated == 0 {
		fmt.Println(ui.Subtle("No running exit nodes found in any region."))
	} else {
		fmt.Printf("%s %s terminated %s instance(s) across %s region(s)\n",
			ui.Checkmark(),
			ui.Success("Shutdown complete:"),
			ui.Bold(fmt.Sprintf("%d", totalTerminated)),
			ui.Bold(fmt.Sprintf("%d", len(regionsWithInstances))))
	}

	return nil
}
